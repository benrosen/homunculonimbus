type NodeEdges {
	inbound(select: EdgesRequest): EdgesResponse
	outbound(select: EdgesRequest): EdgesResponse
}

type Node {
	id: ID!
	edges: NodeEdges!
	features(select: FeaturesRequest): FeaturesResponse!
}

type EdgeNodes {
	origin: Node!
	destination: Node!
}

type Edge {
	id: ID!
	nodes: EdgeNodes
	features(select: FeaturesRequest): FeaturesResponse!
}

type Feature {
	id: String!
	key: String!
	value: String!
	edges(select: EdgesRequest): EdgesResponse
	nodes(select: NodesRequest): NodesResponse!
}

#
#
#

interface Count {
	total: Int
	unique: Int
}

#
#
#

interface FloatReducer {
	mean: Float
	median: Float
	mode: Float
	minimum: Float
	maximum: Float
	total: Float
}

interface StringReducer {
	mostCommon: String
	shortest: String
	longest: String
}

interface BooleanReducer {
	mostCommon: Boolean
}

#
#
#

interface FeatureKeyReducer {
	mostCommon: String
}

interface FeatureValueReducer {
	asBoolean: BooleanReducer
	asFloat: FloatReducer
	asString: StringReducer
}

#
#
#

input BooleanInstanceMatcher {
	equals: Boolean
}

input FloatInstanceMatcher {
	equals: Float
	isGreaterThan: Float
	isGreaterThanOrEqualTo: Float
	isLessThan: Float
	isLessThanOrEqualTo: Float
}

input StringInstanceMatcher {
	equals: String
	startsWith: String
	endsWith: String
	contains: String
}

#
#
#

input FeatureValueInstanceMatcher {
	asBoolean: BooleanInstanceMatcher
	asFloat: FloatInstanceMatcher
	asString: StringInstanceMatcher
}

input FeatureInstanceMatcher {
	id: StringInstanceMatcher
	key: StringInstanceMatcher
	value: FeatureValueInstanceMatcher
}

#input FeatureCollectionMatcher {
#
#}

input FeaturesRequest {
	where: FeatureInstanceMatcher
	limit: Int
	offset: Int
}

#
#
#

interface FeaturesResponse {
	calculate: FeaturesResponseReducer
	enumerate: [Feature]
}

interface FeaturesResponseReducer {
	count: Count
	key: FeatureKeyReducer
	value: FeatureValueReducer
	edges(select: EdgesRequest): EdgesResponseReducer
	nodes(select: NodesRequest): NodesResponseReducer
}

#
#
#

input NodeInstanceMatcher {
	id: StringInstanceMatcher
}

#
#
#

input NodesRequest {
	where: NodeInstanceMatcher
	limit: Int
	offset: Int
}

#
#
#

interface NodesResponse {
	calculate: NodesResponseReducer
	enumerate: [Node]
}

interface NodeEdgesResponseReducer {
	inbound(select: EdgesRequest): EdgesResponseReducer
	outbound(select: EdgesRequest): EdgesResponseReducer
}

interface NodesResponseReducer {
	count: Count
	edges: NodeEdgesResponseReducer
	features(select: FeaturesRequest): FeaturesResponseReducer
}

#
#
#

input EdgeInstanceMatcher {
	id: StringInstanceMatcher
}

#
#
#

input EdgesRequest {
	where: EdgeInstanceMatcher
	limit: Int
	offset: Int
}

#
#
#

interface EdgesResponse {
	calculate: EdgesResponseReducer
	enumerate: [Edge]
}

interface EdgeNodesResponseReducer {
	origin(select: NodesRequest): NodesResponseReducer
	destination(select: NodesRequest): NodesResponseReducer
}

interface EdgesResponseReducer {
	count: Count
	features(select: FeaturesRequest): FeaturesResponseReducer
	nodes: EdgeNodesResponseReducer
}

#
#
#

type Query {
	edges(select: EdgesRequest): EdgesResponse!
	features(select: FeaturesRequest): FeaturesResponse!
	nodes(select: NodesRequest): NodesResponse!
}

#
#
#

# TODO sorting?
# TODO add args to Feature.key and Feature.value?
# TODO logical operators (and or not)?
# TODO array operators (every any none)?
# TODO createdAt timestamps?
