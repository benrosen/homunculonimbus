type Node {
	id: ID!
	edges(select: EdgesRequest): EdgesResponse
	features(select: FeaturesRequest): FeaturesResponse!
}

type Edge {
	id: ID!
	features(select: FeaturesRequest): FeaturesResponse!
	nodes(select: NodesRequest): NodesResponse!
}

type Feature {
	id: String!
	key: String!
	value: String!
	edges(select: EdgesRequest): EdgesResponse
	nodes(select: NodesRequest): NodesResponse!
}

#
#
#

interface Count {
	total: Int
	unique: Int
}

#
#
#

interface FloatReducer {
	mean: Float
	median: Float
	mode: Float
	minimum: Float
	maximum: Float
}

interface StringReducer {
	mostCommon: String
	shortest: String
	longest: String
}

interface BooleanReducer {
	mostCommon: Boolean
}

#
#
#

interface FeatureKeyReducer {
	mostCommon: String
}

interface FeatureValueReducer {
	asBoolean: BooleanReducer
	asFloat: FloatReducer
	asString: StringReducer
}

#
#
#

input BooleanInstanceMatcher {
	equals: Boolean
}

input FloatInstanceMatcher {
	equals: Float
	isGreaterThan: Float
	isGreaterThanOrEqualTo: Float
	isLessThan: Float
	isLessThanOrEqualTo: Float
}

input StringInstanceMatcher {
	equals: String
	startsWith: String
	endsWith: String
	contains: String
}

#
#
#

input FeatureValueInstanceMatcher {
	asBoolean: BooleanInstanceMatcher
	asFloat: FloatInstanceMatcher
	asString: StringInstanceMatcher
}

input FeatureInstanceMatcher {
	id: StringInstanceMatcher
	key: StringInstanceMatcher
	value: FeatureValueInstanceMatcher
}

#input FeatureCollectionMatcher {
#
#}

input FeaturesRequest {
	where: FeatureInstanceMatcher
	limit: Int
	offset: Int
}

#
#
#

interface FeaturesResponse {
	calculate: FeaturesResponseReducer
	enumerate: [Feature]
}

interface FeaturesResponseReducer {
	count: Count
	key: FeatureKeyReducer
	value: FeatureValueReducer
	edges(select: EdgesRequest): EdgesResponseReducer
	nodes(select: NodesRequest): NodesResponseReducer
}

#
#
#

input NodeInstanceMatcher {
	id: StringInstanceMatcher
}

#
#
#

input NodesRequest {
	where: NodeInstanceMatcher
	limit: Int
	offset: Int
}

#
#
#

interface NodesResponse {
	calculate: NodesResponseReducer
	enumerate: [Node]
}

interface NodesResponseReducer {
	count: Count
	edges(select: EdgesRequest): EdgesResponseReducer
	features(select: FeaturesRequest): FeaturesResponseReducer
}

#
#
#

input EdgeInstanceMatcher {
	id: StringInstanceMatcher
}

#
#
#

input EdgesRequest {
	where: EdgeInstanceMatcher
	limit: Int
	offset: Int
}

#
#
#

interface EdgesResponse {
	calculate: EdgesResponseReducer
	enumerate: [Edge]
}

interface EdgesResponseReducer {
	count: Count
	features(select: FeaturesRequest): FeaturesResponseReducer
	nodes(select: NodesRequest): NodesResponseReducer
}

#
#
#

type Query {
	edges(select: EdgesRequest): EdgesResponse!
	features(select: FeaturesRequest): FeaturesResponse!
	nodes(select: NodesRequest): NodesResponse!
}

#
#
#

query getHighScore {
	features(select: {where: {key: {equals: "score"}}}) {
		calculate {
			value {
				asFloat {
					maximum
				}
			}
		}
	}
}

query getAverageScoreByUserId($userId: String!) {
	features(select: {where: {key: {equals: "userId"}, value: {asString: {equals: $userId}}}}) {
		calculate {
			nodes {
				edges {
					nodes {
						features(select: {where: {key: {equals: "score"}}}) {
							value {
								asFloat {
									mean
								}
							}
						}
					}
				}
			}
		}
	}
}

# TODO add directionality to edges
# TODO sorting?
# TODO add args to Feature.key and Feature.value?
# TODO logical operators (and or not)?
# TODO array operators (every any none)?
