##########
##########
##########
##########
##########
##########
##########
##########
##########
##########

type Query {
	edges(select: EdgesRequest): EdgesResponse!
	features(select: FeaturesRequest): FeaturesResponse!
	nodes(select: NodesRequest): NodesResponse!
}

##########
##########
##########
##########
##########
##########
##########
##########
##########
##########

interface DeletedEdgesAndFeatures {
	edges(select: EdgesRequest): EdgesResponse!
	features(select: FeaturesRequest): FeaturesResponse!
}

interface DeleteEdgesResponse {
	deleted: DeletedEdgesAndFeatures
}

interface DeletedFeatures {
	features(select: FeaturesRequest): FeaturesResponse!
}

interface DeleteFeaturesResponse {
	deleted: DeletedFeatures
}

interface DeletedEdgesFeaturesAndNodes {
	edges(select: EdgesRequest): EdgesResponse!
	features(select: FeaturesRequest): FeaturesResponse!
	nodes(select: NodesRequest): NodesResponse!
}

interface DeleteNodesResponse {
	deleted: DeletedEdgesFeaturesAndNodes
}

interface Delete {
	edges(select: EdgesRequest): DeleteEdgesResponse!
	features(select: FeaturesRequest): DeleteFeaturesResponse!
	nodes(select: NodesRequest): DeleteNodesResponse!
}

input NodeEdgeConstructor {
	inbound: CreateEdgesInput
	outbound: CreateEdgesInput
}

input NodeConstructor {
	id: ID
	edges: NodeEdgeConstructor
	features: CreateFeaturesInput
}

input EdgeNodeConstructor {
	destination: NodeConstructor
	origin: NodeConstructor
}

input EdgeConstructor {
	id: ID
	edges: EdgeNodeConstructor
	features: CreateFeaturesInput
}

input CreateEdgesInput {
	constructors: [EdgeConstructor]
}

input CreateNodesinput {
	constructors: [NodeConstructor]
}

input FeatureConstructor {
	id: ID
	key: String
	value: String
	nodes: CreateNodesinput
	edges: CreateEdgesInput
}

input CreateFeaturesInput {
	constructors: [FeatureConstructor]
}

interface CreatedEdgesFeaturesAndNodes {
	edges(select: EdgesRequest): EdgesResponse!
	features(select: FeaturesRequest): FeaturesResponse!
	nodes(select: NodesRequest): NodesResponse!
}

interface CreateEdgesResponse {
	created: CreatedEdgesFeaturesAndNodes
}

interface CreateFeaturesResponse {
	created: CreatedEdgesFeaturesAndNodes
}

interface CreateNodesResponse {
	created: CreatedEdgesFeaturesAndNodes
}

interface Create {
	edges(from: CreateEdgesInput!): CreateEdgesResponse!
	features(from: CreateFeaturesInput!): CreateFeaturesResponse!
	nodes(from: CreateNodesinput!): CreateNodesResponse!
}

type Mutation {
	create: Create
	delete: Delete
	# TODO update
}

mutation {
	create {
		nodes(from: {constructors: [
			{
				id: "foo",
				features: {
					constructors: [
						{id: "foo"}
					]
				}
			}
		]}) {
			created {
				nodes {
					enumerate {
						id
					}
				}
			}
		}
	}
}

##########
##########
##########
##########
##########
##########
##########
##########
##########
##########

# TODO subscriptions

##########
##########
##########
##########
##########
##########
##########
##########
##########
##########

# TODO rewrite as typescript
# TODO deploy appsync api
# TODO create lambda interpreter

input BooleanInstanceMatcher {
	equals: Boolean
}

interface BooleanReducer {
	mostCommon: Boolean
}

interface Count {
	total: Int
	unique: Int
}

interface Edge {
	features(select: FeaturesRequest): FeaturesResponse!
	id: ID!
	nodes: EdgeNodes
}

input EdgeCollectionMatcher {
	any: EdgeInstanceMatcher
	every: EdgeInstanceMatcher
	none: EdgeInstanceMatcher
}

input EdgeCollectionSorter {
	count: FloatSortingOrder
	features: FeatureCollectionSorter
	id: StringInstanceSorter
	nodes: EdgeNodeInstanceSorter
}

input EdgeInstanceMatcher {
	and: [EdgeInstanceMatcher]
	features: FeatureCollectionMatcher
	id: StringInstanceMatcher
	nodes: EdgeNodeInstanceMatcher
	not: [EdgeInstanceMatcher]
	or: [EdgeInstanceMatcher]
}

input EdgeInstanceSorter {
	features: FeatureCollectionSorter
	id: StringInstanceSorter
	nodes: EdgeNodeInstanceSorter
}

input EdgeNodeInstanceMatcher {
	destination: NodeInstanceMatcher
	origin: NodeInstanceMatcher
}

input EdgeNodeInstanceSorter {
	destination: NodeInstanceSorter
	origin: NodeInstanceSorter
}

interface EdgeNodes {
	destination: Node!
	origin: Node!
}

interface EdgeNodesResponseReducer {
	destination(select: NodesRequest): NodesResponseReducer
	origin(select: NodesRequest): NodesResponseReducer
}

input EdgesRequest {
	by: EdgeInstanceSorter
	limit: Int
	offset: Int
	where: EdgeInstanceMatcher
}

interface EdgesResponse {
	calculate: EdgesResponseReducer
	enumerate: [Edge]
}

interface EdgesResponseReducer {
	count: Count
	features(select: FeaturesRequest): FeaturesResponseReducer
	nodes: EdgeNodesResponseReducer
}

interface Feature {
	edges(select: EdgesRequest): EdgesResponse
	id: String!
	key: String!
	nodes(select: NodesRequest): NodesResponse!
	value: String!
}

input FeatureInstanceMatcher {
	and: [FeatureInstanceMatcher]
	edges: EdgeCollectionMatcher
	id: StringInstanceMatcher
	key: StringInstanceMatcher
	nodes: NodeCollectionMatcher
	not: [FeatureInstanceMatcher]
	or: [FeatureInstanceMatcher]
	value: FeatureValueInstanceMatcher
}

input FeatureInstanceSorter {
	edges: EdgeCollectionSorter
	id: StringInstanceSorter
	key: StringInstanceSorter
	nodes: NodeCollectionSorter
	value: FeatureValueInstanceSorter
}

input FeatureCollectionMatcher {
	any: FeatureInstanceMatcher
	every: FeatureInstanceMatcher
	none: FeatureInstanceMatcher
}

input FeatureCollectionSorter {
	count: FloatSortingOrder
	edges: EdgeCollectionSorter
	id: StringInstanceSorter
	key: StringInstanceSorter
	nodes: NodeCollectionSorter
	value: FeatureValueInstanceSorter
}

interface FeatureKeyReducer {
	mostCommon: String
}

input FeaturesRequest {
	by: FeatureInstanceSorter
	limit: Int
	offset: Int
	where: FeatureInstanceMatcher
}

interface FeaturesResponse {
	calculate: FeaturesResponseReducer
	enumerate: [Feature]
}

interface FeaturesResponseReducer {
	count: Count
	edges(select: EdgesRequest): EdgesResponseReducer
	key: FeatureKeyReducer
	nodes(select: NodesRequest): NodesResponseReducer
	value: FeatureValueReducer
}

input FeatureValueInstanceMatcher {
	asBoolean: BooleanInstanceMatcher
	asFloat: FloatInstanceMatcher
	asString: StringInstanceMatcher
	asTimestamp: TimestampInstanceMatcher
}

input FeatureValueInstanceSorter {
	asFloat: FloatSortingOrder
	asString: StringInstanceSorter
	asTimestamp: TimestampSortingOrder
}

interface FeatureValueReducer {
	asBoolean: BooleanReducer
	asFloat: FloatReducer
	asString: StringReducer
	asTimestamp: TimestampReducer
}

input FloatInstanceMatcher {
	equals: Float
	isGreaterThan: Float
	isGreaterThanOrEqualTo: Float
	isLessThan: Float
	isLessThanOrEqualTo: Float
}

interface FloatReducer {
	mean: Float
	median: Float
	mode: Float
	minimum: Float
	maximum: Float
	total: Float
}

enum FloatSortingOrder {
	smallestToLargest
	largestToSmallest
}

interface Node {
	edges: NodeEdges!
	features(select: FeaturesRequest): FeaturesResponse!
	id: ID!
}

input NodeCollectionMatcher {
	any: NodeInstanceMatcher
	every: NodeInstanceMatcher
	none: NodeInstanceMatcher
}

input NodeCollectionSorter {
	count: FloatSortingOrder
	edges: NodeEdgeInstanceSorter
	features: FeatureCollectionSorter
	id: StringInstanceSorter
}

input NodeEdgeCollectionMatcher {
	inbound: EdgeCollectionMatcher
	outbound: EdgeCollectionMatcher
}

# TODO rename this to NodeEdgesCollectionSorter?
input NodeEdgeInstanceSorter {
	inbound: EdgeCollectionSorter
	outbound: EdgeCollectionSorter
}

interface NodeEdges {
	inbound(select: EdgesRequest): EdgesResponse
	outbound(select: EdgesRequest): EdgesResponse
}

interface NodeEdgesResponseReducer {
	inbound(select: EdgesRequest): EdgesResponseReducer
	outbound(select: EdgesRequest): EdgesResponseReducer
}

input NodeInstanceMatcher {
	and: [NodeInstanceMatcher]
	edges: NodeEdgeCollectionMatcher
	features: FeatureCollectionMatcher
	id: StringInstanceMatcher
	or: [NodeInstanceMatcher]
	not: [NodeInstanceMatcher]
}

input NodeInstanceSorter {
	edges: NodeEdgeInstanceSorter
	features: FeatureCollectionSorter
	id: StringInstanceSorter
}

input NodesRequest {
	by: NodeInstanceSorter
	limit: Int
	offset: Int
	where: NodeInstanceMatcher
}

interface NodesResponse {
	calculate: NodesResponseReducer
	enumerate: [Node]
}

interface NodesResponseReducer {
	count: Count
	edges: NodeEdgesResponseReducer
	features(select: FeaturesRequest): FeaturesResponseReducer
}

input StringInstanceMatcher {
	contains: String
	endsWith: String
	equals: String
	startsWith: String
}

input StringInstanceSorter {
	alphabetical: StringSortingOrder
	length: FloatSortingOrder
}

interface StringReducer {
	longest: String
	mostCommon: String
	shortest: String
}

enum StringSortingOrder {
	aToZ
	zToA
}

input TimestampInstanceMatcher {
	equals: Int
	isGreaterThan: Int
	isGreaterThanOrEqualTo: Int
	isLessThan: Int
	isLessThanOrEqualTo: Int
}

interface TimestampReducer {
	maximum: Int
	mean: Int
	median: Int
	minimum: Int
	mode: Int
	total: Int
}

enum TimestampSortingOrder {
	newestToOldest
	oldestToNewest
}
