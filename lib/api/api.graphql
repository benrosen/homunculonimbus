type NodeEdges {
	inbound(select: EdgesRequest): EdgesResponse
	outbound(select: EdgesRequest): EdgesResponse
}

type Node {
	id: ID!
	edges: NodeEdges!
	features(select: FeaturesRequest): FeaturesResponse!
}

type EdgeNodes {
	origin: Node!
	destination: Node!
}

type Edge {
	id: ID!
	nodes: EdgeNodes
	features(select: FeaturesRequest): FeaturesResponse!
}

type Feature {
	id: String!
	key: String!
	value: String!
	edges(select: EdgesRequest): EdgesResponse
	nodes(select: NodesRequest): NodesResponse!
}

#
#
#

interface Count {
	total: Int
	unique: Int
}

#
#
#

interface FloatReducer {
	mean: Float
	median: Float
	mode: Float
	minimum: Float
	maximum: Float
	total: Float
}

interface StringReducer {
	mostCommon: String
	shortest: String
	longest: String
}

interface BooleanReducer {
	mostCommon: Boolean
}

interface TimestampReducer {
	mean: Int
	median: Int
	mode: Int
	minimum: Int
	maximum: Int
	total: Int
}

#
#
#

interface FeatureKeyReducer {
	mostCommon: String
}

interface FeatureValueReducer {
	asBoolean: BooleanReducer
	asFloat: FloatReducer
	asString: StringReducer
	asTimestamp: TimestampReducer
}

#
#
#

input BooleanInstanceMatcher {
	equals: Boolean
}

input FloatInstanceMatcher {
	equals: Float
	isGreaterThan: Float
	isGreaterThanOrEqualTo: Float
	isLessThan: Float
	isLessThanOrEqualTo: Float
}

input StringInstanceMatcher {
	equals: String
	startsWith: String
	endsWith: String
	contains: String
}

input TimestampInstanceMatcher {
	equals: Int
	isGreaterThan: Int
	isGreaterThanOrEqualTo: Int
	isLessThan: Int
	isLessThanOrEqualTo: Int
}

#
#
#

enum FloatSortingOrder {
	SmallerToBigger
	BiggerToSmaller
}

enum StringSortingOrder {
	AToZ
	ZToA
}

enum TimestampSortingOrder {
	NewerToOlder
	OlderToNewer
}

#
#
#

input StringInstanceSorter {
	length: FloatSortingOrder
	alphabetical: StringSortingOrder
}

#
#
#

input FeatureValueInstanceMatcher {
	asBoolean: BooleanInstanceMatcher
	asFloat: FloatInstanceMatcher
	asString: StringInstanceMatcher
	asTimestamp: TimestampInstanceMatcher
}

input FeatureInstanceMatcher {
	id: StringInstanceMatcher
	key: StringInstanceMatcher
	value: FeatureValueInstanceMatcher
	nodes: NodeCollectionMatcher
	edges: EdgeCollectionMatcher
	and: [FeatureInstanceMatcher]
	or: [FeatureInstanceMatcher]
	not: [FeatureInstanceMatcher]
}

input FeatureCollectionMatcher {
	any: FeatureInstanceMatcher
	every: FeatureInstanceMatcher
	none: FeatureInstanceMatcher
}

input FeatureValueInstanceSorter {
	asFloat: FloatSortingOrder
	asString: StringInstanceSorter
	asTimestamp: TimestampSortingOrder
}

input FeatureCollectionSorter {
	count: FloatSortingOrder
	id: StringInstanceSorter
	key: StringInstanceSorter
	value: FeatureValueInstanceSorter
	nodes: NodeCollectionSorter
	edges: EdgeCollectionSorter
}

input FeatureInstanceSorter {
	id: StringInstanceSorter
	key: StringInstanceSorter
	value: FeatureValueInstanceSorter
	nodes: NodeCollectionSorter
	edges: EdgeCollectionSorter
}

input FeaturesRequest {
	where: FeatureInstanceMatcher
	by: FeatureInstanceSorter
	limit: Int
	offset: Int
}

#
#
#

interface FeaturesResponse {
	calculate: FeaturesResponseReducer
	enumerate: [Feature]
}

interface FeaturesResponseReducer {
	count: Count
	key: FeatureKeyReducer
	value: FeatureValueReducer
	edges(select: EdgesRequest): EdgesResponseReducer
	nodes(select: NodesRequest): NodesResponseReducer
}

#
#
#

input NodeEdgeCollectionMatcher {
	inbound: EdgeCollectionMatcher
	outbound: EdgeCollectionMatcher
}

input NodeInstanceMatcher {
	id: StringInstanceMatcher
	features: FeatureCollectionMatcher
	edges: NodeEdgeCollectionMatcher
	and: [NodeInstanceMatcher]
	or: [NodeInstanceMatcher]
	not: [NodeInstanceMatcher]
}

input NodeCollectionMatcher {
	any: NodeInstanceMatcher
	every: NodeInstanceMatcher
	none: NodeInstanceMatcher
}

#
#
#

input NodeEdgeInstanceSorter {
	outbound: EdgeCollectionSorter
	inbound: EdgeCollectionSorter
}

input NodeCollectionSorter {
	count: FloatSortingOrder
	id: StringInstanceSorter
	edges: NodeEdgeInstanceSorter
	features: FeatureCollectionSorter
}

input NodeInstanceSorter {
	id: StringInstanceSorter
	edges: NodeEdgeInstanceSorter
	features: FeatureCollectionSorter
}

input NodesRequest {
	where: NodeInstanceMatcher
	by: NodeInstanceSorter
	limit: Int
	offset: Int
}

#
#
#

interface NodesResponse {
	calculate: NodesResponseReducer
	enumerate: [Node]
}

interface NodeEdgesResponseReducer {
	inbound(select: EdgesRequest): EdgesResponseReducer
	outbound(select: EdgesRequest): EdgesResponseReducer
}

interface NodesResponseReducer {
	count: Count
	edges: NodeEdgesResponseReducer
	features(select: FeaturesRequest): FeaturesResponseReducer
}

#
#
#

input EdgeNodeInstanceMatcher {
	origin: NodeInstanceMatcher
	destination: NodeInstanceMatcher
}

input EdgeInstanceMatcher {
	id: StringInstanceMatcher
	features: FeatureCollectionMatcher
	nodes: EdgeNodeInstanceMatcher
	and: [EdgeInstanceMatcher]
	or: [EdgeInstanceMatcher]
	not: [EdgeInstanceMatcher]
}

input EdgeCollectionMatcher {
	any: EdgeInstanceMatcher
	every: EdgeInstanceMatcher
	none: EdgeInstanceMatcher
}

#
#
#


input EdgeNodeInstanceSorter {
	origin: NodeInstanceSorter
	destination: NodeInstanceSorter
}

input EdgeCollectionSorter {
	count: FloatSortingOrder
	id: StringInstanceSorter
	nodes: EdgeNodeInstanceSorter
	features: FeatureCollectionSorter
}

input EdgeInstanceSorter {
	id: StringInstanceSorter
	nodes: EdgeNodeInstanceSorter
	features: FeatureCollectionSorter
}

input EdgesRequest {
	where: EdgeInstanceMatcher
	by: EdgeInstanceSorter
	limit: Int
	offset: Int
}

#
#
#

interface EdgesResponse {
	calculate: EdgesResponseReducer
	enumerate: [Edge]
}

interface EdgeNodesResponseReducer {
	origin(select: NodesRequest): NodesResponseReducer
	destination(select: NodesRequest): NodesResponseReducer
}

interface EdgesResponseReducer {
	count: Count
	features(select: FeaturesRequest): FeaturesResponseReducer
	nodes: EdgeNodesResponseReducer
}

#
#
#

type Query {
	edges(select: EdgesRequest): EdgesResponse!
	features(select: FeaturesRequest): FeaturesResponse!
	nodes(select: NodesRequest): NodesResponse!
}

#
#
#
